---
import { join } from 'node:path';

import {
  isSidebarGroup,
  type SidebarGroup,
  type SidebarItem,
  type SidebarLink,
} from '~/layouts/nav/sidebar-items';
import { kebabToTitleCase } from '~/utils/string';
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';

import DocsLayout, { type Props as DocsLayoutProps } from '../../layouts/docs-layout.astro';
import {
  resolvePageTitle,
  resolveRootCategory,
  resolveSubCategory,
  sidebarItemsOrder,
} from '../../layouts/nav/docs-sidebar-items';
import type { DocsFileIdentifiers, DocsPagination } from '../../layouts/nav/docs-sidebar-items';
import { getJSLibraryFromPathname } from '../../stores/libraries';

let { pathname } = Astro.url,
  jsLibrary = getJSLibraryFromPathname(pathname),
  jsLibPrefix = jsLibrary === 'react' ? '' : 'wc',
  jsLibSegment = '/' + (jsLibrary === 'web-components' ? 'wc' : jsLibrary) + '/',
  overviewRE = /^(.*?)\/overview/,
  jsLibRE = /\/(wc|react)\//,
  indexRE = /index\..+$/,
  basePath = '/docs',
  slug = pathname.replace(/\/$/, ''),
  pages = await getPages(),
  page = findPage(pages, slug),
  props = page ? buildProps(pages, page) : null;

async function getPages() {
  const pages = await getCollection('docs');
  return pages.filter((page) => !jsLibRE.test(page.slug) || page.slug.includes(jsLibSegment));
}

function buildProps(
  pages: CollectionEntry<'docs'>[],
  currentPage: CollectionEntry<'docs'>,
): DocsLayoutProps {
  const sidebarId = resolveSidebarId(currentPage.id),
    rootCategory = resolveRootCategory(sidebarId),
    { items, pagination } = buildSidebarItems(pages, currentPage, rootCategory);
  return {
    jsLibrary,
    page: { ...currentPage, slug: slug as any },
    pageTitle: resolvePageTitle(currentPage),
    pagination,
    category: resolveSubCategory(sidebarId) || rootCategory,
    sidebar: {
      id: sidebarId,
      root: rootCategory,
      items,
      deepMatch: currentPage.slug.includes('/installation'),
    },
  };
}

function resolvePageSlug(page: CollectionEntry<'docs'>) {
  const filteredPageSlug = page.slug.replace(jsLibRE, '/').replace(overviewRE, '$1');
  return `${basePath}/${filteredPageSlug.includes('installation') ? filteredPageSlug : join(jsLibPrefix, filteredPageSlug)}`;
}

function resolveSidebarId(id: string) {
  return id.replace(jsLibRE, '/').replace(/.*?\//, '');
}

function findPage(pages: CollectionEntry<'docs'>[], slug: string) {
  for (const page of pages) {
    if (resolvePageSlug(page) === slug) return page;
  }

  return null;
}

function isCategory(page: CollectionEntry<'docs'>, category: string) {
  const sidebarId = resolveSidebarId(page.id);
  return resolveRootCategory(sidebarId) === category;
}

function buildSidebarItems(
  pages: CollectionEntry<'docs'>[],
  currentPage: CollectionEntry<'docs'>,
  currentCategory: string,
) {
  // Pages that belong to this category.
  const validPages: CollectionEntry<'docs'>[] = [],
    items: SidebarItem[] = [],
    pagination: DocsPagination = {},
    seen = new Set<string>(),
    skip = new Set<DocsFileIdentifiers>(['player/components/index.mdx']);

  for (const page of pages) {
    const id = page.id.replace(jsLibRE, '/');
    if (!skip.has(page.id) && !seen.has(id) && isCategory(page, currentCategory)) {
      validPages.push(page);
      seen.add(id);
    }
  }

  const orderedItems = sidebarItemsOrder[currentCategory];
  validPages.sort((a, b) => orderedItems.indexOf(a.id) - orderedItems.indexOf(b.id));

  for (let i = 0; i < validPages.length; i++) {
    const page = validPages[i],
      sidebarId = resolveSidebarId(page.id);

    // TODO: trying to avoid deep matches showing up multiple times, this is really lazy.
    if (!page.data.title?.includes('Installation Guide')) {
      let segments = sidebarId.split('/').slice(1, indexRE.test(sidebarId) ? -2 : -1),
        sidebarTitle = page.data.sidebar_title || resolvePageTitle(page),
        group = items;

      for (const segment of segments) {
        let title = kebabToTitleCase(segment),
          next = group.find((item) => isSidebarGroup(item) && item.title === title) as
            | SidebarGroup
            | undefined;

        if (!next) group.push((next = { title, items: [] }));

        group = next.items;
      }

      const item: SidebarLink = {
        title: sidebarTitle,
        href: resolvePageSlug(page),
      };

      group.push(item);
    }

    if (page === currentPage) {
      const prevPage = validPages[i - 1],
        nextPage = validPages[i + 1];

      if (prevPage) {
        pagination.prev = {
          title: resolvePageTitle(prevPage),
          href: resolvePageSlug(prevPage),
        };
      }

      if (nextPage) {
        pagination.next = {
          title: resolvePageTitle(nextPage),
          href: resolvePageSlug(nextPage),
        };
      }
    }
  }

  return { items, pagination };
}

if (!props) {
  return new Response(null, { status: 404 });
}
---

<DocsLayout {...props} />
